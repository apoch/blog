<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[The Bag of Holding]]></title><description><![CDATA[A bottomless satchel once possessed by a knight-errant.]]></description><link>https://apoch.github.io/blog</link><image><url>/ThorDogOfThunder.jpg</url><title>The Bag of Holding</title><link>https://apoch.github.io/blog</link></image><generator>RSS for Node</generator><lastBuildDate>Fri, 02 Jun 2017 03:14:40 GMT</lastBuildDate><atom:link href="https://apoch.github.io/blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Epoch 64-bit compiler progress]]></title><description><![CDATA[<div class="paragraph">
<p>Just a short while ago, the first working 64-bit compiler for <a href="https://github.com/apoch/epoch-language">Epoch</a> was produced!</p>
</div>
<div class="paragraph">
<p>Well, "working" might be a minor stretch; it launches, prints a simple text banner message, and then exits cleanly. But that represents a lot of operational code by itself.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The 32-bit compiler is able to lex, parse, type-check, and code-gen the entirety of the 64-bit compiler&#8217;s source code.</p>
</li>
<li>
<p>The 32-bit linker can emit 64-bit binaries, assisted by LLVM&#8217;s machine code generation facilities.</p>
</li>
<li>
<p>The 64-bit compiler binary is a completely functional Windows executable image.</p>
</li>
<li>
<p>This executable can run to completion on 64-bit Windows versions.</p>
</li>
<li>
<p>Inside the compiled binary is a table of string constants.</p>
</li>
<li>
<p>64-bit Epoch code can load those strings and route them out to the command-line console.</p>
</li>
<li>
<p>A number of support DLL calls are involved in this process, including loading garbage collection metadata and stack tracing for identifying GC roots.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All told there are hundreds of thousands of lines of code involved. Building the 64-bit compiler takes about 164 seconds (just over two and a half minutes) when using debug versions of LLVM. (For comparison, the 32-bit compiler can self-host in under 20 seconds, but that&#8217;s an unfair comparison because that build process uses optimized Release versions of LLVM.)</p>
</div>
<div class="paragraph">
<p>I&#8217;m pretty pleased with this progress. There are still many things left to get working, though.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>64-bit globals do not work correctly; all of them are currently stuffed into a single random address which may or may not crash when dereferenced.</p>
</li>
<li>
<p>More support DLL calls need to be implemented or eliminated.</p>
</li>
<li>
<p>Certain code constructs do not work correctly yet; this is worked around for the time being by not using them in the compiler, but they will be good to get working as soon as is practical.</p>
</li>
<li>
<p>A large number of hacks and temporary shims exist in the linker. This will need to be cleaned up substantially before self-hosting is really practical.</p>
</li>
<li>
<p>Debug metadata and symbols are not generated correctly yet.</p>
</li>
<li>
<p>Visual Studio integration has a number of bugs, ranging from the pesky to the outright unusable.</p>
</li>
<li>
<p>It is exceedingly likely that there will be bugs in the compiler, meaning that 64-bit self-hosting is still a ways out even if the basics are operational.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Making the highly optimisic presumption that this will all happen soon, I think it&#8217;s fair to say that once all of the above is addressed (and 64-bit self-hosting is complete) it will be time to cut another release of Epoch.</p>
</div>
<div class="paragraph">
<p>In all probability, though, I&#8217;ll course-correct sometime between now and then, but it never hurts to have objectives!</p>
</div>]]></description><link>https://apoch.github.io/blog/2017/05/30/Epoch-64-bit-compiler-progress.html</link><guid isPermaLink="true">https://apoch.github.io/blog/2017/05/30/Epoch-64-bit-compiler-progress.html</guid><dc:creator><![CDATA[Mike Lewis]]></dc:creator><pubDate>Tue, 30 May 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Epoch Code-Generation Update]]></title><description><![CDATA[<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>A few minutes ago, the first 64-bit self-hosted compiler for Epoch finished the code-generation process&#8230;&#8203; unsuccessfully.</p>
</div>
<div class="paragraph">
<p>For context, this means that the 64-bit compiler (as built by the existing 32-bit compiler) was lexed, parsed, type-checked, and turned into LLVM IR. What <em>didn&#8217;t</em> happen is a successful code emission, i.e. the compiler is not yet producing a working executable image.</p>
</div>
<div class="paragraph">
<p>What it <em>does</em> produce is about 6.8 MB of errors, or just over 121,000 lines of output. This indicates that something in the code-gen process is off. We&#8217;re generating LLVM IR but it can&#8217;t be turned into machine code because it is malformed in some way.</p>
</div>
<div class="paragraph">
<p>Inspection of the error output shows that one of the biggest offenses is bad linkage on a global variable. Epoch aspires to minimize the use of global state but it&#8217;s a useful construct while bootstrapping a compiler. Fixing this mistake is trivial and reduces the error volume to much less.</p>
</div>
<div class="paragraph">
<p>In fact, the vast bulk of the output is actually the text of the LLVM IR in pretty-printed form. This "dump" is generated to help diagnose code-gen bugs, but it&#8217;s meant for much smaller programs than the entire compiler! Culling the dumped IR shows that there are in fact only <strong>208</strong> errors left (after the global linkage fiasco was addressed). And all of them are the same "sort" of error&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_terminator_found_in_the_middle_of_a_basic_block">Terminator found in the middle of a basic block!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>LLVM divides code into sections called <em>basic blocks</em>. A single basic block represents a linear sequence of instructions, i.e. every instruction in it is executed exactly once. The way to accomplish branching flow control is to <strong>end</strong> a basic block with a branch instruction, likely a conditional branch of some kind. Branches target <em>other</em> basic blocks to allow different code paths to execute based on the branch.</p>
</div>
<div class="paragraph">
<p>The dreaded error "Terminator found in the middle of a basic block!" means that the constraints have been violated. Someone tried to issue a branch instruction in the middle of a block, which ruins the idea that every instruction in the block executes exactly once.</p>
</div>
<div class="paragraph">
<p>In concrete terms, this error signals a bug in the code generation process. It means that somewhere along the line, the Epoch compiler lost track of a basic block being terminated, and continued shoving instructions into it after a branch.</p>
</div>
<div class="paragraph">
<p>Thankfully, LLVM barfs a "label" when it emits this error, and that label is sufficient to locate the offending basic block:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1&gt;  ; &lt;label&gt;:41                                      ; preds = %11
1&gt;    br label %9, !dbg !3338
1&gt;    br label %42</pre>
</div>
</div>
<div class="paragraph">
<p>Sure enough, there are two branches being attempted here. The larger context is uninteresting (it&#8217;s a nested if-statement inside a binary tree insertion routine) but the specific failure appears many times, meaning that it&#8217;s probably a small number of actual code-generation bugs to solve.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_1_2_3">Testing, 1 2 3</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As with any good software, robustness in a compiler happens only when enough bugs have been fixed <em>while simultaneously ensuring that no new ones are introduced</em>. The best tool I know of for doing this is <em>automated testing</em>. Now that a compiler bug has been identified, the objective is to replicate it in as tiny a program as possible.</p>
</div>
<div class="paragraph">
<p>This "test case" provides two things: a way to reproduce the bug on-demand so a fix can be tested, and a way to detect if the bug ever reappears. The Epoch compiler test suite is still small, but invaluable for addressing this sort of problem. I will add this particular code to the test suite and hopefully have a fix in short order.</p>
</div>
</div>
</div>]]></description><link>https://apoch.github.io/blog/2017/05/29/Epoch-Code-Generation-Update.html</link><guid isPermaLink="true">https://apoch.github.io/blog/2017/05/29/Epoch-Code-Generation-Update.html</guid><dc:creator><![CDATA[Mike Lewis]]></dc:creator><pubDate>Mon, 29 May 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Epoch 64-bit self-hosting progress]]></title><description><![CDATA[<div class="paragraph">
<p>For a decent while now, I&#8217;ve been working on <em>self-hosting</em> the <a href="https://github.com/apoch/epoch-language">Epoch</a> 64-bit compiler. This involves getting the compiler to a point where it is robust enough to actually compile itself. In order to do this, I&#8217;m using a modified 32-bit compiler which generates 64-bit binaries. Once a working 64-bit compiler is emitted, I can feed <em>that</em> compiler back into itself, thus completing the head-trip ouroboros that is self-hosting or "bootstrapping" a compiler.</p>
</div>
<div class="paragraph">
<p>At the moment, the compiler can successfully lex, parse, type-check, and partially code-gen itself. In practical terms, this means that the <em>front-end</em> of the compiler is working fine, but the <em>back-end</em> - the set of systems responsible for turning code into machine language and emitting a working executable - remains incomplete. For a slightly different perspective, I&#8217;m generating LLVM IR for <em>most</em> of the compiler at this point.</p>
</div>
<div class="paragraph">
<p>The bits that are left are corner cases in the code generation engine. There are things like intrinsic functions that need to be wired up, special semantics to implement, and so on. In particular, right now, I&#8217;m working on solving a corner case with the <code>nothing</code> concept. <code>nothing</code> is an Epoch idiom for expressing the idea that there is no data; except, unlike traditional <code>null</code>, <code>nothing</code> is its own <em>type</em>. If something has a type it cannot be <code>nothing</code> - again, unlike <code>null</code>. The usefulness of this may seem questionable, but the distinction makes it possible to avoid entire classes of runtime bugs, because you can never "forget" to write code that handles <code>nothing</code> - the compiler enforces this for you!</p>
</div>
<div class="paragraph">
<p>Anyways, the trick with <code>nothing</code> is that you can pass a literal <code>nothing</code> to a function as an argument, to signify that you have no semantically valid data to pass in. This is handled correctly by the parser and type checker, but falls down in code generation because we can&#8217;t actually omit the parameter from the function call.</p>
</div>
<div class="paragraph">
<p>What happens is the code generator creates a function with, say, 3 parameters. If the second parameter is <code>nothing</code> at a call site, we have to still pass <em>something</em> over to the function, from LLVM&#8217;s perspective. So we generate a dummy parameter that essentially translates the <code>nothing</code> semantics into <code>null</code> semantics - something LLVM can recognize.</p>
</div>
<div class="paragraph">
<p>Now things get complicated.</p>
</div>
<div class="paragraph">
<p>If we have an algebraic sum type that includes the type <code>nothing</code>, and we pass a sum-typed variable into a function which expects <em>concrete</em> types, the code goes through a process called <em>type dispatching</em>. This process basically matches an overload of a function with the <em>runtime</em> types of the arguments passed in. Think of it like virtual dispatch with no objects involved. (Strictly speaking, type dispatch in Epoch is <em>multiple dispatch</em> rather than the <em>single dispatch</em> seen in more popular languages.)</p>
</div>
<div class="paragraph">
<p>To facilitate all this, the compiler inserts <em>annotations</em> into the code, so that it can deduce what set of overloads to choose from when the runtime dispatcher is invoked. Some of these annotations survive at runtime - analogs of <em>virtual-table pointers</em> in C++.</p>
</div>
<div class="paragraph">
<p>Annotations are passed as hidden parameters on the stack when invoking a function. And at last we reach the real wrinkle: a <code>nothing</code> annotation can come from <em>two distinct places</em>: either the construction of a sum-typed variable which allows <code>nothing</code> as a base type, or a literal <code>nothing</code> passed to a function call.</p>
</div>
<div class="paragraph">
<p>The headache is that, to LLVM, <em>both uses look like a function call</em>. There is special case logic that exists to fix up the annotations for sum-typed constructors. Unfortunately, that logic collides with the logic needed to fix up annotations for general function call usage because LLVM doesn&#8217;t know the difference.</p>
</div>
<div class="paragraph">
<p>It&#8217;s an imminently solvable problem, but it&#8217;s a headache. Hopefully once this bug is gone there won&#8217;t be <em>too</em> many more to swat before I can start code-generating working 64-bit compilers.</p>
</div>
<div class="paragraph">
<p>(Spoiler: I&#8217;m not optimistic.)</p>
</div>]]></description><link>https://apoch.github.io/blog/2017/05/29/Epoch-64-bit-self-hosting-progress.html</link><guid isPermaLink="true">https://apoch.github.io/blog/2017/05/29/Epoch-64-bit-self-hosting-progress.html</guid><dc:creator><![CDATA[Mike Lewis]]></dc:creator><pubDate>Mon, 29 May 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Welcome to the Bag of Holding]]></title><description><![CDATA[<div class="paragraph">
<p>This is a quick test of HubPress.io to see how I like it. Assuming all goes well, I will probably resume posting Bag of Holding entries here soon. Ancient archives from the Bag of Holding are on <a href="https://www.gamedev.net/blog/355-the-bag-of-holding/">GameDev.net</a> if you happen to like my writing. They are very, very old though.</p>
</div>
<div class="paragraph">
<p>For now, here&#8217;s a sneak preview of where <a href="https://github.com/apoch/epoch-language">Epoch</a> is headed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>simplelist&lt;integer&gt; types = new 0, nothing</pre>
</div>
</div>]]></description><link>https://apoch.github.io/blog/2017/05/28/Welcome-to-the-Bag-of-Holding.html</link><guid isPermaLink="true">https://apoch.github.io/blog/2017/05/28/Welcome-to-the-Bag-of-Holding.html</guid><dc:creator><![CDATA[Mike Lewis]]></dc:creator><pubDate>Sun, 28 May 2017 00:00:00 GMT</pubDate></item></channel></rss>
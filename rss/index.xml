<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[The Bag of Holding]]></title><description><![CDATA[A bottomless satchel once possessed by a knight-errant.]]></description><link>https://apoch.github.io/blog</link><image><url>/ThorDogOfThunder.jpg</url><title>The Bag of Holding</title><link>https://apoch.github.io/blog</link></image><generator>RSS for Node</generator><lastBuildDate>Mon, 29 May 2017 22:05:09 GMT</lastBuildDate><atom:link href="https://apoch.github.io/blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Epoch 64-bit self-hosting progress]]></title><description><![CDATA[<div class="paragraph">
<p>For a decent while now, I&#8217;ve been working on <em>self-hosting</em> the <a href="https://github.com/apoch/epoch-language">Epoch</a> 64-bit compiler. This involves getting the compiler to a point where it is robust enough to actually compile itself. In order to do this, I&#8217;m using a modified 32-bit compiler which generates 64-bit binaries. Once a working 64-bit compiler is emitted, I can feed <em>that</em> compiler back into itself, thus completing the head-trip ouroboros that is self-hosting or "bootstrapping" a compiler.</p>
</div>
<div class="paragraph">
<p>At the moment, the compiler can successfully lex, parse, type-check, and partially code-gen itself. In practical terms, this means that the <em>front-end</em> of the compiler is working fine, but the <em>back-end</em> - the set of systems responsible for turning code into machine language and emitting a working executable - remains incomplete. For a slightly different perspective, I&#8217;m generating LLVM IR for <em>most</em> of the compiler at this point.</p>
</div>
<div class="paragraph">
<p>The bits that are left are corner cases in the code generation engine. There are things like intrinsic functions that need to be wired up, special semantics to implement, and so on. In particular, right now, I&#8217;m working on solving a corner case with the <code>nothing</code> concept. <code>nothing</code> is an Epoch idiom for expressing the idea that there is no data; except, unlike traditional <code>null</code>, <code>nothing</code> is its own <em>type</em>. If something has a type it cannot be <code>nothing</code> - again, unlike <code>null</code>. The usefulness of this may seem questionable, but the distinction makes it possible to avoid entire classes of runtime bugs, because you can never "forget" to write code that handles <code>nothing</code> - the compiler enforces this for you!</p>
</div>
<div class="paragraph">
<p>Anyways, the trick with <code>nothing</code> is that you can pass a literal <code>nothing</code> to a function as an argument, to signify that you have no semantically valid data to pass in. This is handled correctly by the parser and type checker, but falls down in code generation because we can&#8217;t actually omit the parameter from the function call.</p>
</div>
<div class="paragraph">
<p>What happens is the code generator creates a function with, say, 3 parameters. If the second parameter is <code>nothing</code> at a call site, we have to still pass <em>something</em> over to the function, from LLVM&#8217;s perspective. So we generate a dummy parameter that essentially translates the <code>nothing</code> semantics into <code>null</code> semantics - something LLVM can recognize.</p>
</div>
<div class="paragraph">
<p>Now things get complicated.</p>
</div>
<div class="paragraph">
<p>If we have an algebraic sum type that includes the type <code>nothing</code>, and we pass a sum-typed variable into a function which expects <em>concrete</em> types, the code goes through a process called <em>type dispatching</em>. This process basically matches an overload of a function with the <em>runtime</em> types of the arguments passed in. Think of it like virtual dispatch with no objects involved. (Strictly speaking, type dispatch in Epoch is <em>multiple dispatch</em> rather than the <em>single dispatch</em> seen in more popular languages.)</p>
</div>
<div class="paragraph">
<p>To facilitate all this, the compiler inserts <em>annotations</em> into the code, so that it can deduce what set of overloads to choose from when the runtime dispatcher is invoked. Some of these annotations survive at runtime - analogs of <em>virtual-table pointers</em> in C++.</p>
</div>
<div class="paragraph">
<p>Annotations are passed as hidden parameters on the stack when invoking a function. And at last we reach the real wrinkle: a <code>nothing</code> annotation can come from <em>two distinct places</em>: either the construction of a sum-typed variable which allows <code>nothing</code> as a base type, or a literal <code>nothing</code> passed to a function call.</p>
</div>
<div class="paragraph">
<p>The headache is that, to LLVM, <em>both uses look like a function call</em>. There is special case logic that exists to fix up the annotations for sum-typed constructors. Unfortunately, that logic collides with the logic needed to fix up annotations for general function call usage because LLVM doesn&#8217;t know the difference.</p>
</div>
<div class="paragraph">
<p>It&#8217;s an imminently solvable problem, but it&#8217;s a headache. Hopefully once this bug is gone there won&#8217;t be <em>too</em> many more to swat before I can start code-generating working 64-bit compilers.</p>
</div>
<div class="paragraph">
<p>(Spoiler: I&#8217;m not optimistic.)</p>
</div>]]></description><link>https://apoch.github.io/blog/2017/05/29/Epoch-64-bit-self-hosting-progress.html</link><guid isPermaLink="true">https://apoch.github.io/blog/2017/05/29/Epoch-64-bit-self-hosting-progress.html</guid><dc:creator><![CDATA[Mike Lewis]]></dc:creator><pubDate>Mon, 29 May 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Welcome to the Bag of Holding]]></title><description><![CDATA[<div class="paragraph">
<p>This is a quick test of HubPress.io to see how I like it. Assuming all goes well, I will probably resume posting Bag of Holding entries here soon. Ancient archives from the Bag of Holding are on <a href="https://www.gamedev.net/blog/355-the-bag-of-holding/">GameDev.net</a> if you happen to like my writing. They are very, very old though.</p>
</div>
<div class="paragraph">
<p>For now, here&#8217;s a sneak preview of where <a href="https://github.com/apoch/epoch-language">Epoch</a> is headed:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>simplelist&lt;integer&gt; types = new 0, nothing</pre>
</div>
</div>]]></description><link>https://apoch.github.io/blog/2017/05/28/Welcome-to-the-Bag-of-Holding.html</link><guid isPermaLink="true">https://apoch.github.io/blog/2017/05/28/Welcome-to-the-Bag-of-Holding.html</guid><dc:creator><![CDATA[Mike Lewis]]></dc:creator><pubDate>Sun, 28 May 2017 00:00:00 GMT</pubDate></item></channel></rss>